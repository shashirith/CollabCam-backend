[{"heading":"Race Condition","body":"Race condition is a situation where several processes access and manipulate the same data\nconcurrently and the outcome of the execution depends on the particular order in which the\naccesses take place.\nTo avoid such situations, it must be ensured that only one process can manipulate the data at a\ngiven time.\nThis can be done by process synchronization."},{"heading":"Round robin (RR) scheduling ","body":"- a small time quantum or time slice is defined\n- the ready queue is treated as a circular queue\n- each process is allocated the CPU for one time quantum\n- preemptive\n- if time quantum is too large, then RR behaves like FCFS\n- if time quantum is too small, then RR behaves like processor sharing\n- rule of thumb: 80% CPU bursts should be shorter than the time quantum"},{"heading":"Dispatcher","body":"A dispatcher is the module of the operating system that gives control of the CPU to the process\nselected by the CPU scheduler.\nSteps –\n- switching context\n- switching to user mode\n- jumping to the proper location in the user program\nDispatch latency is the time taken to stop a"},{"heading":"A critical section problem is defined as follows –","body":"- there are n processes, viz. P0, P1, P2 ... Pn-1\n- each process has a section of code, called the critical section, in which the process changes\ncommon variables and files\n- the problem is to ensure that when one process is executing in its critical section then no\nother process can execute its own critical section\n- the critical section is preceded by an entry section in which a process seeks permission from\nother processes\n- the critical section is followed by an exit section"},{"heading":"A solution to the critical section problem must satisfy","body":" the following properties –\n- Mutual exclusion\n- Progress - If no process is in its critical section and some processes want to enter\ntheir critical sections, then the processes which are in their entry\nsections or exit sections decide which process will enter its critical\nsection next. \n- Bounded waiting - There is a limit on the number of times other processes are allowed to\nenter their critical sections after a process has made a request to enter\nits critical section and before that request is granted."},{"heading":"Binary semaphore –","body":"- also called mutex lock\n- used to implement solution of critical section problem with multiple processes\n- initialized to 1\ndo { wait (mutex);\ncritical section\nsignal (mutex);\nremainder section\n} while (true);"},{"heading":"Dining philosophers problem","body":"Semaphores –\nchopsticks[5];\nall initialized to 1\nPi\ndo { wait (chopstick[i]);\nwait (chopStick[(i+1)%5]);\n// eat\nsignal (chopstick[i]);\nsignal (chopstick[(i+1)%5]);\n// think\n} while (true);"},{"heading":"Monitor","body":"A monitor is a high-level process synchronization construct.\nOnly one process can be active within the monitor at a time.\nA monitor type presents a set of programmer defined operations that are provided mutual exclusion\nwithin the monitor.\nA monitor can have variables of the condition type that can be accessed by wait() and signal()\noperations only."},{"heading":"Necessary conditions for deadlocks","body":"- Mutual exclusion - one or more non-sharable resources\n- Hold and wait - a process is holding some resources and waiting for other resources\n- No preemption - resources cannot be preempted\n- Circular wait - a set {P0, P1, P2 ... Pn} exist such that P0 is waiting for resources held by\nP1, P1 is waiting for resources held by P2, and so on, and Pn is waiting\nfor resources held by P0\n\nCircular wait implies hold and wait."},{"heading":"Methods for handling deadlocks –","body":"- Deadlock prevention\n- Deadlock avoidance\n- Deadlock detection and recovery\nNo deadlock handling mechanism –\n- deadlocks are infrequent, may be only once in a year\n- deadlock handling is expensive"},{"heading":"Contiguous memory allocation –","body":"- Static: divide the memory into fixed-sized blocks\n- allocate one block to each process\n- number of partitions controls the degree of multiprogramming\n\n- Dynamic: allocate available space to a process\n\n- Keep track of holes\n- strategies: first-fit, best-fit, worst fit\n- the worst-fit strategy results in large leftover holes (reusable)\n\n- Contiguous memory allocation leads to external fragmentation\n\n- there may be enough memory left to accommodate a process but it is\nscattered\n- solution: compaction (costly)"}]